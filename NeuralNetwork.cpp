/*
Farokh Confectioner
CS144 Neural network Project
*/

#include "NeuralNetwork.h"
#include "ActivationFunction.h"

using namespace std;

void NeuralNetwork::Initialization(int input_nodes, int hidden_nodes, 
								int output_nodes, double learning_rate) {

	this->input_nodes = input_nodes;
	this->hidden_nodes = hidden_nodes;
	this->output_nodes = output_nodes;
	this->learning_rate = learning_rate;
}

void NeuralNetwork::train() {
	cout << "Training Neural Network." << endl;

	ifstream training_file("C:\\Users\\Lyght\\Desktop\\SJSU Fall 2017\\CS 144\\Neural Network - Final Project - Farokh Confectioner\\mnist_train.csv");
	string currentdata;
	int i = 0;

	while (getline(training_file, currentdata) && i < 1000) {

		Matrix i_input(input_nodes, 1);
		int k = 0;
		for (int j = 1; j < input_nodes; j++) {
			if (currentdata[j] != ',') {
				i_input.SetVal(k++, 0, currentdata[j]);
			}
		}

		//Set input matrix values here.
		//Plug in values of the image into the matrix.
		//Generate random weights: W
		w_input_hidden = RandomWeightsMatrix(hidden_nodes, input_nodes);
		w_hidden_output = RandomWeightsMatrix(output_nodes, hidden_nodes);

		try {

			//Get resultant matrix X and pass it into layer 2 by doing X = W * I
			Matrix x_input_hidden = w_input_hidden * i_input;

			//Apply sigmoid function to resultant matrix X.
			//Output matrix is generated by sigmoid function.
			Matrix o_input_hidden = x_input_hidden.ApplySigmoid();

			//Do this one more time for the third layer. 

			//Get resultant matrix X and pass it into layer 2 by doing X = W * I
			Matrix x_hidden_output = w_hidden_output * o_input_hidden;

			//Apply sigmoid function to resultant matrix X.
			Matrix o_hidden_output = x_hidden_output.ApplySigmoid();

			//currentdata[0] - 48 gets the actual numerical value instead of ascii.
			Matrix expected_output = GetExpectedOutputs(currentdata[0] - 48);
			Matrix final_error(output_nodes, 1);
			final_error = CaclulateFinalError(o_hidden_output, expected_output);

			//Get the hidden error and calculate the slope error.
			Matrix error_hidden = w_hidden_output.GetTranspose() * final_error;

			Matrix slope_err = SlopeError(w_hidden_output, o_hidden_output, 
				expected_output);

			//Update the weights of the slope error.
			w_hidden_output = UpdateWeights(w_hidden_output, learning_rate, slope_err);
		}
		catch (exception e) {
			cout << "Error found" << endl;
		}

		cout << "Iteration: " << i++ << endl;
	}
	cout << "Training complete." << endl;
}

void NeuralNetwork::query() {
	cout << "Querying" << endl;

	ifstream training_file("C:\\Users\\Lyght\\Desktop\\SJSU Fall 2017\\CS 144\\Neural Network - Final Project - Farokh Confectioner\\mnist_test.csv");
	string currentdata;
	int i = 0;

	while (getline(training_file, currentdata) && i < 100) {
		Matrix i_input(input_nodes, 1);
		int k = 0;
		for (int j = 1; j < input_nodes; j++) {
			if (currentdata[j] != ',') {
				i_input.SetVal(k++, 0, currentdata[j]);
			}
		}

		try {
			//Passing inputs through first layer.
			Matrix x_input_hidden = w_input_hidden * i_input;

			//Applying sigmoid to output of hidden layer.
			Matrix o_input_hidden = x_input_hidden.ApplySigmoid();

			//Calculating output values.
			Matrix x_hidden_output = w_hidden_output * o_input_hidden;

			//Applying sigmoid to outputs.
			Matrix o_hidden_output = x_hidden_output.ApplySigmoid();

			int calculated_value = this->GetNumberValue(o_hidden_output);

			cout << "Actual value: " << currentdata[0] << ", estimated value: " << calculated_value << endl;

			for (int j = 0; j < 10; j++) {
				cout << "Probability of " << j << ": " << 
					o_hidden_output.GetVal(j, 0) << endl;
			}
			
			cout << "--------------------------------------------------" << endl;
			i++;
		}
		catch (exception e) {
			cout << "Error found" << endl;
		}
	}
}

Matrix NeuralNetwork::RandomWeightsMatrix(int x_size, int y_size) {
	Matrix random_weights(x_size, y_size);

	for (int x = 0; x < x_size; x++) {
		for (int y = 0; y < y_size; y++) {
			double random_val = ((double)rand()) / ((double)RAND_MAX);
			random_val = (2 * random_val - 1) / sqrt(y_size);
			random_weights.SetVal(x, y, random_val);
		}
	}
	return random_weights;
}

//Matrix NeuralNetwork::SlopeError(Matrix weights, 
//	Matrix output, Matrix training_data) {
//	for (int j = 0; j < weights.GetRows(); j++) {
//		for (int k = 0; k < weights.GetColumns(); k++) {
//			double error = (-1) * 
//				CalculateError(training_data.GetVal(j, 0), output.GetVal(j, 0));
//			double sum_w_o = 0;
//			double output_val = output.GetVal(j, 0);
//			for (int i = 0; i < weights.GetRows(); i++) {
//				sum_w_o += weights.GetVal(j, k) * output_val;
//			}
//			double sigmoid_sum = ActivationFunction::SigmoidFunction(sum_w_o);
//			double slope_err = error * sigmoid_sum * (1 - sigmoid_sum) * output_val;
//		}
//	}
//	return weights;
//}

Matrix NeuralNetwork::SlopeError(Matrix weights,
	Matrix output, Matrix training_data) {

	double sum_w_o = 0;

	for (int j = 0; j < weights.GetRows(); j++) {
		for (int k = 0; k < weights.GetColumns(); k++) {
			double error = (-1) *
				CalculateError(training_data.GetVal(j, 0), output.GetVal(j, 0));
			
			double output_val = output.GetVal(j, 0);
			//for (int i = 0; i < weights.GetRows(); i++) {
			sum_w_o += weights.GetVal(j, k) * output_val;
			//}
			double sigmoid_sum = ActivationFunction::SigmoidFunction(sum_w_o);
			double slope_err = error * sigmoid_sum * (1 - sigmoid_sum) * output_val;
		}
	}
	return weights;
}

Matrix NeuralNetwork::CaclulateFinalError(Matrix calc_output, 
											Matrix expected_output) {
	Matrix error_matrix(calc_output.GetRows(), 1);

	for (int i = 0; i < calc_output.GetRows(); i++) {
		error_matrix.SetVal(i, 0, CalculateError(calc_output.GetVal(i, 0),
			expected_output.GetVal(i, 0)));
	}
	return error_matrix;
}

double NeuralNetwork::CalculateError(double training_data, double output_data) {
	return training_data - output_data;
}

Matrix NeuralNetwork::UpdateWeights(Matrix old_weights, 
	double learning_rate, Matrix slope_error) {
	Matrix new_weights(old_weights.GetRows(), old_weights.GetColumns());
	for (int i = 0; i < old_weights.GetRows(); i++) {
		for (int j = 0; j < old_weights.GetColumns(); j++) {
			double weight = old_weights.GetVal(i, j) - 
				(learning_rate * slope_error.GetVal(i, j));
			new_weights.SetVal(i, j, weight);
		}
	}
	return new_weights;
}

Matrix NeuralNetwork::GetExpectedOutputs(int expected_output) {
	Matrix output(10, 1);
	output.SetVal(expected_output, 0, 1);
	return output;
}

int NeuralNetwork::GetNumberValue(Matrix output_matrix) {
	double max = 0;
	int ret_val = 0;
	for (int i = 0; i < output_matrix.GetRows(); i++) {
		double current_value = output_matrix.GetVal(i, 0);
		if (max < current_value) {
			max = current_value;
			ret_val = i;
		}
	}
	return ret_val;
}

int main() {
	NeuralNetwork n;
	n.Initialization(n.INPUT_NODES, n.HIDDEN_NODES, n.OUTPUT_NODES, n.LEARNING_RATE);
	n.train();
	n.query();
}